---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by mac.
--- DateTime: 2021/10/1 9:46 下午
---
local encrypt = require "kong.plugins.request-encrypt.encrypt"
local json = require "cjson"
local rsa = require "resty.rsa"
local redis = require "resty.redis"
local kong = kong
local ngx = ngx

local _M = {}

local function failed_and_exit(conf, message, code)
    code = code or conf.not_encrypt_status
    kong.response.exit(code, { massage = message })
end

-- Verify whether the signature is reused through redis, put each used signature into redis,
-- and cache it for a period of time to prevent the request from being replayed in a short time
--
-- @string signature Signature of this request
-- @tab conf The plug-in configuration
-- @return void
local function signature_redis_prevent_replay(conf, signature)
    local redis_cli = redis:new()
    redis_cli:set_timeout(1000);
    local ok, err = redis_cli:connect(conf.redis_host, conf.redis_port)
    if not ok then
        kong.log.err("Signature module failed to connect to redis :", err)
        failed_and_exit(conf, "Failed to connect to redis", 500)
    end

    if conf.redis_pass and conf.redis_pass ~= "" then
        ok, err = redis_cli:auth(conf.redis_pass)
        if not ok then
            kong.log.err("Signature module failed to connect to redis: ", err)
            failed_and_exit(conf, "Failed to connect to redis", 500)
        end
    end

    redis_cli:select(conf.redis_database)
    -- Determine whether the signature has been used, if the current signature exists in redis,
    -- return an error response directly to prevent the request from being replayed
    local incr
    incr, err = redis_cli:incr(signature)
    if err then
        kong.log.err("Signature module failed to operate redis: ", err)
        failed_and_exit(conf, "Failed to operate redis", 500)
    end

    if incr > 1 then
        failed_and_exit(conf, "Signature failure")
    end

    redis_cli:expire(signature, conf.signature_timeout)
    -- Put this redis connection into the connection pool, reusable connection,
    -- Warning: Please ensure that it is a normal and usable connection
    redis_cli:set_keepalive(600000, 20)
end

-- From the request header, get the signature and related parameters generated by the signature,
-- and verify whether the signature is legal
--
-- @tab conf The plug-in configuration
-- @string secret The key used in the signature
-- @string body Entire request body
-- @return void
local function signature_verify(conf, secret, body)
    if not conf.signature_enabled then return end

    local signature = kong.request.get_header("signature")
    local nonce_str = kong.request.get_header("nonce-str")
    local timestamp = kong.request.get_header('timestamp')
    if not signature or not nonce_str or not timestamp
            or math.abs(ngx.time() - timestamp) > 5 then
        failed_and_exit(conf, "Failed to verify the signature")
    end

    local signature_by_server = ngx.md5(timestamp .. nonce_str .. ngx.encode_base64(body) .. secret)
    if signature_by_server ~= signature then
        failed_and_exit(conf, "Failed to verify the signature")
    end

    if conf.signature_redis_enabled then
        signature_redis_prevent_replay(conf, signature_by_server)
    end
end

-- Check whether the requested body conforms to the specification, and return an error response directly
-- if it does not conform to the specification
--
-- @tab parameters Request body JSON after parsing
-- @return void
local function parameters_verify(parameters)
    if not parameters.path or not parameters.method then
        failed_and_exit(conf, "Incomplete request", 422)
    end

    if parameters.body and type(parameters.body) ~= "table" then
        failed_and_exit(conf, "Unexpected Request Body", 422)
    end
end

function _M.execute(conf)

    if (conf.request_enabled or conf.signature_enabled or conf.response_enabled)
            and kong.request.get_method() ~= "OPTIONS" then

        -- Get the rsa encrypted key from the request header
        -- Obtain the symmetric encryption and signature verification key
        -- through the configured private key decryption
        local secret_cipher, secret = kong.request.get_header("secret"), ""
        if not secret_cipher then failed_and_exit(conf, "The required parameters are missing") end

        local pri, err = rsa:new({ private_key = conf.rsa_pri_key })
        if not pri then
            kong.log.err("Failed to obtain the key: ", err)
            failed_and_exit(conf, "Failed to obtain the key", 500)
        end

        secret, err = pri:decrypt(ngx.decode_base64(secret_cipher))
        if err then
            kong.log.err("Failed to parse the key: ", err)
            failed_and_exit(conf, "Failed to parse the key", 500)
        end

        kong.ctx.shared.secret = secret

        local body = kong.request.get_raw_body()
        if conf.signature_enabled then signature_verify(conf, secret, body) end

        -- If request encryption is turned on
        -- The requested data needs to be extracted from the encrypted request body
        -- Such as: method, path, etc., and then re-assign the corresponding data through kong api
        -- When kong forwards the request, it will carry the data we configured
        if conf.request_enabled then
            local plaintext_body = json.decode(encrypt.decode(secret, body))
            parameters_verify(plaintext_body)

            kong.service.request.set_path(plaintext_body.path)
            kong.service.request.set_method(plaintext_body.method:upper())

            if plaintext_body.query then
                kong.service.request.set_raw_query(plaintext_body.query)
            end

            if plaintext_body.body then
                kong.service.request.set_raw_body(
                        json.encode(plaintext_body.body))
            end
        end
    end
end

return _M